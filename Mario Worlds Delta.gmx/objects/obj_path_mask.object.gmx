<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_path</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>-8</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///The guider

//Direction, not the array one
dir = 0;

//Circle movement specific variable, theres 2 ways to move to move each 4 circle pieces
alt_dir = 0;

//Direction, Array
type = 0;

//Circle Movement, Array
type_b = 0; 

//Speed
speeds = 1;

//Circle Movement pivoting setup
pivot_x = 0;
pivot_y = 0;
pivot_radius = 0;
pivot_direction = 0; 

//ID assigned to place the pivot
myd = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Find a path modifier to move around

var near = collision_rectangle(bbox_left, bbox_top, bbox_right, bbox_bottom, obj_path_changer, 1, 0);
if (near &amp;&amp; (!near.ready)) {

    //align to that near object
    x = near.x;
    y = near.y;
    
    //if that near object is marked as a launch 
    if (near.launch_dir != -1)
    &amp;&amp; (gravity == 0) {
    
        //Launch if the type(array) matches the exact same number assigned as the launch_dir
        if (near.launch_dir == type) {
        
            //Set up gravity
            gravity = 0.27;
            
            //Jump when it moves up
            hspeed = near.m[1];
            vspeed = near.m[0];
            
            //Reverse direction, array
            type = !type;
            type_b = !type_b;
        }

    }
    else {
    
        //Get the information from the modifier, like this Direction below
        dir = near.dir[type]; 
        
        //Get the information from the modifier, like this Direction below, for the circle
        //Only use when you're gonna make it do a circle movement
        alt_dir = near.rev_dir[type_b];
        
        //Avoid repeating the movement
        near.ready = true; 
        near.platform = id;
        
        //Disable gravity
        gravity = 0;

        //Set pivot for circular movement
        near = myd;
        
        //Get pivot coodirnates, for circle movement
        grab_pivots();
    }
}


//Find the nearest modifier while falling down
var far_near = collision_rectangle(x-32,y-32,x+32,y+32,obj_path_changer,1,0);

//The only type
if (far_near)
&amp;&amp; (gravity != 0)
&amp;&amp; (hspeed != 0)
&amp;&amp; (far_near.launch_dir == -1) {

    //Snap that point
    gravity = 0;
    x = far_near.x;
    y = far_near.y;
}

//Cap vertical speed when falling fown
if (vspeed &gt;= 3)
    vspeed = 3;
    
//Find a path limit
var lim = collision_rectangle(bbox_left, bbox_top, bbox_right, bbox_bottom, obj_path_limit, 1, 0);
if (lim &amp;&amp; (!lim.ready)) {

    //Reverse direction, array
    type = !type;
    type_b = !type_b;
    
    //Set pivot for circular movement
    lim = myd;
    
    //Change movement too
    event_user(0);
    
    lim.ready = true; 
    lim.platform = id;
    
    //Also reverse the second or first direction for circles
    alt_dir = type_b;
    
    //Get pivot coodirnates, for circle movement
    grab_pivots();
    
    //if (wfc != 0)
    //    dir_cs
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Collection of path movement

//Keywords
//CCircle = 32x32 radius
//SL = Slanted line
//S = Steep line

//Exit if gravity is enabled
if (gravity != 0) exit;

//The macros speak for itself 
if (dir == cs_up) {

    //Set the direction
    vspeed = -speeds;
    hspeed = 0;
}
else if (dir == cs_down) {

    //Set the direction
    vspeed = speeds;
    hspeed = 0;
}
else if (dir == cs_left) {

    //Set the direction
    vspeed = 0;
    hspeed = -speeds;
}
else if (dir == cs_right) {

    //Set the direction
    vspeed = 0;
    hspeed = speeds;
}
else if (dir == cs_upleft) {

    //Set the direction
    vspeed = -speeds;
    hspeed = -speeds;
}
else if (dir == cs_upright) {

    //Set the direction
    vspeed = -speeds;
    hspeed = speeds;
}
else if (dir == cs_downright) {

    //Set the direction
    vspeed = speeds;
    hspeed = speeds;
}
else if (dir == cs_downleft) {

    //Set the direction
    vspeed = speeds;
    hspeed = -speeds;
}
else if (dir == cs_downright_sl) {

    //Set the direction
    vspeed = speeds/2;
    hspeed = speeds;
}
else if (dir == cs_downleft_sl) {

    //Set the direction
    vspeed = speeds/2;
    hspeed = -speeds;
}
else if (dir == cs_upleft_sl) {

    //Set the direction
    vspeed = -speeds/2;
    hspeed = -speeds;
}
else if (dir == cs_upright_sl) {

    //Set the direction
    vspeed = -speeds/2;
    hspeed = speeds;
}
//
else if (dir == cs_downright_s) {

    //Set the direction
    vspeed = speeds;
    hspeed = speeds/2;
}
else if (dir == cs_downleft_s) {

    //Set the direction
    vspeed = speeds;
    hspeed = -speeds/2;
}
else if (dir == cs_upleft_s) {

    //Set the direction
    vspeed = -speeds;
    hspeed = -speeds/2;
}
else if (dir == cs_upright_s) {

    //Set the direction
    vspeed = -speeds;
    hspeed = speeds/2;
}
else if (dir == cs_circle_upright
|| dir == cs_ccircle_upright) {

    //WARNING they have 2 ways to move using one path direction
    //code by Minty Python
    vspeed = 0;
    hspeed = 0;
    if (alt_dir == 0) {
    
        //clockwise
        pivot_direction = max(pivot_direction - radtodeg(speeds/pivot_radius), 90);
        x  = pivot_x + lengthdir_x(pivot_radius, pivot_direction);
        y  = pivot_y + lengthdir_y(pivot_radius, pivot_direction);
    }
    else if (alt_dir == 1) {
    
        //counter clockwise
        pivot_direction = min(pivot_direction + radtodeg(speeds/pivot_radius), 180);
        x  = pivot_x + lengthdir_x(pivot_radius, pivot_direction);
        y  = pivot_y + lengthdir_y(pivot_radius, pivot_direction);
    }
}
else if (dir == cs_circle_upleft
|| dir == cs_ccircle_upleft) {

    //WARNING they have 2 ways to move using one path direction
    //code by Minty Python
    vspeed = 0;
    hspeed = 0;
    if (alt_dir == 1) {
    
        //clockwise
        pivot_direction = max(pivot_direction - radtodeg(speeds/pivot_radius), 0);
        x  = pivot_x + lengthdir_x(pivot_radius, pivot_direction);
        y  = pivot_y + lengthdir_y(pivot_radius, pivot_direction);
    }
    else if (alt_dir == 0) {
    
        //counter clockwise
        pivot_direction = min(pivot_direction + radtodeg(speeds/pivot_radius), 90);
        x  = pivot_x + lengthdir_x(pivot_radius, pivot_direction);
        y  = pivot_y + lengthdir_y(pivot_radius, pivot_direction);
    }
}
else if (dir == cs_circle_downright
|| dir == cs_ccircle_downright) {

    //WARNING they have 2 ways to move using one path direction
    //code by Minty Python
    vspeed = 0;
    hspeed = 0;
    if (alt_dir == 1) {
    
        //clockwise
        pivot_direction = max(pivot_direction - radtodeg(speeds/pivot_radius), 180);
        x  = pivot_x + lengthdir_x(pivot_radius, pivot_direction);
        y  = pivot_y + lengthdir_y(pivot_radius, pivot_direction);
    }
    else if (alt_dir == 0) {
    
        //counter clockwise
        pivot_direction = min(pivot_direction + radtodeg(speeds/pivot_radius), 270);
        x  = pivot_x + lengthdir_x(pivot_radius, pivot_direction);
        y  = pivot_y + lengthdir_y(pivot_radius, pivot_direction);
    }
}
else if (dir == cs_circle_downleft
|| dir == cs_ccircle_downleft) {

    //WARNING they have 2 ways to move using one path direction
    //code by Minty Python
    vspeed = 0;
    hspeed = 0;
    if (alt_dir == 0) {
    
        //clockwise
        pivot_direction = max(pivot_direction - radtodeg(speeds/pivot_radius), 270);
        x  = pivot_x + lengthdir_x(pivot_radius, pivot_direction);
        y  = pivot_y + lengthdir_y(pivot_radius, pivot_direction);
    }
    else if (alt_dir == 1) {
    
        //counter clockwise
        pivot_direction = min(pivot_direction + radtodeg(speeds/pivot_radius), 360);
       x  = pivot_x + lengthdir_x(pivot_radius, pivot_direction);
        y  = pivot_y + lengthdir_y(pivot_radius, pivot_direction);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Rervese direction

//Don't look at this it will hurt you eyes :p
//Done for you, so you don't need to manually type which direction!
if (dir == cs_left)
    dir = cs_right;
else if (dir == cs_right)
    dir = cs_left;
else if (dir == cs_up)
    dir = cs_down;
else if (dir == cs_down)
    dir = cs_up;
//Diagonal
if (dir == cs_downleft)
    dir = cs_downright;
else if (dir == cs_downright)
    dir = cs_downleft;
else if (dir == cs_upright)
    dir = cs_upleft;
else if (dir == cs_upleft)
    dir = cs_upright;
if (dir == cs_downleft_sl)
    dir = cs_downright_sl;
else if (dir == cs_downright_sl)
    dir = cs_downleft_sl;
else if (dir == cs_upright_sl)
    dir = cs_upleft_sl;
else if (dir == cs_upleft_sl)
    dir = cs_upright_sl;
if (dir == cs_downleft_s)
    dir = cs_downright_s;
else if (dir == cs_downright_s)
    dir = cs_downleft_s;
else if (dir == cs_upright_s)
    dir = cs_upleft_s;
else if (dir == cs_upleft_s)
    dir = cs_upright_s;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
