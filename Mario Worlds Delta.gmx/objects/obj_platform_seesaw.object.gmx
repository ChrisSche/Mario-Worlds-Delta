<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_platform_seesaw_80</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Seesaw platform

//Angle of the slope
degree = image_angle;

//Elevation
extra = 20;

//Angle 
image_angle = 0;

//Speed of angle
add = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Player on the platform

//If player ever exists
if (instance_exists(obj_playerparent)) {

    with (obj_playerparent) {
    
        //Check for a seesaw
        var see = collision_rectangle(bbox_left, bbox_bottom-2, bbox_right, bbox_bottom+4, obj_platform_seesaw, 1, 0);
        
        //If that ground exists and the player is above it...
        if (see)  
        &amp;&amp; (!collision_rectangle(bbox_left, bbox_top+4, bbox_right, see.y-1, obj_solid, 1, 0)) {
            
            //If player is falling down or landed
            if (vspeed &gt;= 0) {
            
                //Make a theoretical triangle in order to calculate the y position
                var real_y = -(x-see.x)*dsin(see.degree); 
                var real_x = (x-see.x)*dcos(see.degree);
                var fake_x = x - see.x;
                var fake_y = clamp(real_y*fake_x/real_x, -see.sprite_width/2, see.sprite_width/2);
                
                //Adjust players y position
                y = see.y + fake_y-see.extra;
                
                //If platform ever moves horizontally, adjust players x
                x += see.x-see.xprevious;
                
                //Stop vertical movement
                vspeed = 0;
                gravity = 0;
                
                //Reset values for player
                event_user(15);
            }
        }   
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Seesaw Logic

//If player ever exists
if (instance_exists(obj_playerparent)) {

    //If player is on seesaw
    if (obj_playerparent.gravity == 0)
    &amp;&amp; (place_meeting(x, y-8, obj_playerparent)) {
    
        //Rotate seesaw relative to player position
        image_angle += add;
        add += -(1/70)*(obj_playerparent.x - x);
        
        //Limit speed
        if (abs(add) &gt; 1.3) 
            add = 1.3 * sign(x-obj_playerparent.x);
    
        //Set player horizontal speed 
        obj_playerparent.hspeed -= (0.05+(abs(image_angle)/360))*sign(image_angle);
    }
    else {
    
        //Otherwise slow down the rotation
        add = max(0,abs(add)-0.04)*sign(add);
        image_angle += add;
    }
}

//Set angle value calculation
degree = image_angle;

//Player elavation to not embed deep into platform
extra = 20+(abs(image_angle)/20);

//Limit angle 
if (image_angle &gt;= 45)
    image_angle = 45; 
else if (image_angle &lt;= -45)
    image_angle = -45; 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Render seesaw

draw_sprite_ext(sprite_index, 0, x, y, 1, 1, image_angle, c_white, 1);

//Render gear 
if (!place_meeting(x,y,obj_movingseesaw))
    draw_sprite_ext(sprite_index, 1, x, y+4, 1, 1, 0, c_white, 1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
