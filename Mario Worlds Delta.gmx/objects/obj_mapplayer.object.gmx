<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_mapmario</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>spr_square</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///It's the player... on the map!

//Check if the position was modified before
if (ds_map_exists(global.worldmap, "playerx")) {

    //Place the player where it belongs
    x = ds_map_find_value(global.worldmap, "playerx");
    y = ds_map_find_value(global.worldmap, "playery");
}
else {

    //Set up the current position
    ds_map_add(global.worldmap, "playerx", x);
    ds_map_add(global.worldmap, "playery", y);
}

//Animate the object
image_speed = 0.125;

//Whether the object is moving
status = mapstate.idle;

//Speed
spd = 1;

//Origin
xorig = 7;
yorig = 7;

//Steps to take per steps
step = 0;

//Direction
direct = 270;

//Whether the player is climbing
is_climbing = 0;

//Whether the player is swimming
is_swimming = 0;

//Whether the player has selected a stage
is_ready = 0;

//Scale
xscale = 1;

//Reset global variables
variable_global_reset();

//Tick for another player to show up (lower for map entry)
player_wait = -20;

//Time for the player to show up
wait_time = 8;

//Previous player
last_player = global.player;

//To save the game
savegame = false;

//If the level has been beaten
if (global.clear &gt; 0) {

    alarm[0] = 30;
    status = mapstate.wait;   
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Set up 'mapstate.idle' status if in 'mapstate.preidle' state

if (status == mapstate.preidle)
    status = mapstate.idle;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Save the game

//Normal exit
if (!savegame &amp;&amp; !global.alt_save) {
    
    status = mapstate.idle;
    exit;
    
}

//Otherwise, save

//If autosaving is enabled
if (global.autosave == 1) {

    save(global.file);
    status = mapstate.idle;
    obj_hud_map.show_saved = true;
    obj_hud_map.alarm[0] = 90;
    
} else {

    //Create save object
    instance_create(0,0,obj_save);
    
}
    
savegame = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Open adjacent paths depending of what exit was found

//Find nearest panel
check = collision_point(x+xorig, y+yorig, obj_levelpanel, 0, 0);

//Handle the visual "clear levels" for the title screen
with (check) {

    //If you didn't warp...
    if (global.clear &lt; 3) {

        //And the normal/secret exit wasn't cleared...
        if (is_undefined(ds_map_find_value(global.worldmap_beaten,string(id)+"_"+string(global.clear)))) {
        
            //Note this
            global.cleared_levels ++;
            ds_map_replace(global.worldmap_beaten,string(id)+"_"+string(global.clear),1);
        
        }
        
    }
    
}

//If the level has been cleared with the normal exit
if (global.clear == 1) {

    //If this panel is a switch palace, do not open paths
    if (check.paneltype == 2) {
        
        savegame = true;
    
        //Mark panel as beaten
        with (check) {
        
            ds_map_replace(global.worldmap, id, 2);
            alarm[2] = 1;
            exit;
        }           
    }
    
    //Otherwise
    else {

        //If this panel is a castle
        if (check.paneltype == 1) {
        
            if (check.beaten != 2) {
            
                savegame = true;
            
                with (check) {
                
                    ds_map_replace(global.worldmap, id, 2);
                    alarm[2] = 1;
                    exit;                    
                }         
            }            
        }
    
        //Check what exit was set in the panel
        switch (check.normalexit) {
        
            //Up
            case (cs_up): {
        
                //Check for a path above and open it if it is not visible
                var pathU = collision_point(x+xorig, y+yorig-8, obj_pathparent, 0, 0);
                
                //If the path exists
                if (pathU) 
                &amp;&amp; (pathU.image_alpha == 0)
                    with (instance_create(x, y, obj_mapopener)) direct = 90;
            } break;
            
            //Down
            case (cs_down): {
                
                //Check for a path below and open it if it is not visible
                var pathD = collision_point(x+xorig, y+yorig+9, obj_pathparent, 0, 0);
                
                //If the path exists
                if (pathD) 
                &amp;&amp; (pathD.image_alpha == 0) 
                    with (instance_create(x, y, obj_mapopener)) direct = 270;
            } break;
            
            //Left
            case (cs_left): {
                
                //Check for a path at the left and open it if it is not visible
                var pathL = collision_point(x+xorig-8, y+yorig, obj_pathparent, 0, 0);
                
                //If the path exists
                if (pathL) 
                &amp;&amp; (pathL.image_alpha == 0)
                    with (instance_create(x, y, obj_mapopener)) direct = 180;
            } break;
            
            //Right
            case (cs_right): {
                
                //Check for a path at the right and open it if it is not visible
                var pathR = collision_point(x+xorig+9, y+yorig, obj_pathparent, 0, 0);
                
                //If the path exists
                if (pathR) 
                &amp;&amp; (pathR.image_alpha == 0)
                    with (instance_create(x, y, obj_mapopener)) direct = 0;
            } break;    
        }
    }
}

//Otherwise, if the level has been cleared with the secret exit
else if (global.clear == 2) {

    //Check what exit was set in the panel
    switch (check.secretexit) {
    
        //Up
        case (cs_up): {
    
            //Check for a path above and open it if it is not visible
            var pathU = collision_point(x+xorig, y+yorig-8, obj_pathparent, 0, 0);
            
            //If the path exists
            if (pathU) 
            &amp;&amp; (pathU.image_alpha == 0)
                with (instance_create(x, y, obj_mapopener)) direct = 90;
        } break;
        
        //Down
        case (cs_down): {
            
            //Check for a path below and open it if it is not visible
            var pathD = collision_point(x+xorig, y+yorig+9, obj_pathparent, 0, 0);
            
            //If the path exists
            if (pathD) 
            &amp;&amp; (pathD.image_alpha == 0) 
                with (instance_create(x, y, obj_mapopener)) direct = 270;
        } break;
        
        //Left
        case (cs_left): {
            
            //Check for a path at the left and open it if it is not visible
            var pathL = collision_point(x+xorig-8, y+yorig, obj_pathparent, 0, 0);
            
            //If the path exists
            if (pathL) 
            &amp;&amp; (pathL.image_alpha == 0)
                with (instance_create(x, y, obj_mapopener)) direct = 180;
        } break;
        
        //Right
        case (cs_right): {
            
            //Check for a path at the right and open it if it is not visible
            var pathR = collision_point(x+xorig+9, y+yorig, obj_pathparent, 0, 0);
            
            //If the path exists
            if (pathR) 
            &amp;&amp; (pathR.image_alpha == 0)
                with (instance_create(x, y, obj_mapopener)) direct = 0;
        } break;    
    }    
}

//Otherwise, if the player warped through a pipe
else if (global.clear == 3) {

    event_user(15);
}

//Mark level as beaten
with (check) {

    if (paneltype != 1) {
    
        ds_map_replace(global.worldmap_beaten, id, 1);
        
    }
    
}

//Reset clear variable
global.clear = 0;

if (instance_exists(check)) {

    //If no map openers were made...
    if ((instance_number(obj_mapopener) == 0) &amp;&amp; (check.paneltype == 0)) {
        
        //Save game
        alarm[1] = 2;
    
    }
    
} else {

    status = mapstate.idle;
    
}

//Do not remember checkpoint for this level
if (variable_instance_exists(check, "checkpoint"))
    with (check) checkpoint = noone;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Animate the object

var current_player = global.player;

if (status == mapstate.switching) {

    global.player = last_player;

}

//If the player is ready
if (is_ready) {

    //Set the sprite
    sprite_index = player_map_select();
    
    //Set up the scale
    xscale = 1;
    
    //Set up the frame
    image_speed = 0;
    image_index = is_swimming;
}

//Otherwise
else {
    
    //If climbing
    if (is_climbing) {
    
        //Set up the scale
        xscale = 1;
        
        //If the player is riding a yoshi
        if (global.mount != 0)
            sprite_index = player_map_up();
        else
            sprite_index = player_map_climb();    
    }
    
    //Otherwise, if not climbing
    else {
    
        //If moving down or stopped
        if (direct == 270)
        || (status == mapstate.idle) {
        
            //Set up the sprite
            sprite_index = player_map();
        
            //Reset scale
            if (xscale != 1)
                xscale = 1;
        }
        
        //Otherwise, if moving up
        else if (direct == 90) {
        
            //Set up the sprite
            sprite_index = player_map_up();
        
            //Reset scale
            if (xscale != 1)
                xscale = 1;
        }
            
        //Otherwise, if moving to the side
        else {
            
            //Set up the sprite
            sprite_index = player_map_side();
            
            //Set the scale
            if (direct == 0)
                xscale = 1;
            else
                xscale = -1;
        }
    }
}

global.player = current_player;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Map player logic

//Check for a node
node = collision_point(x+xorig, y+yorig, obj_node, 0, 0);

//Update animation speed
image_speed = 0.125;

//If the player is not moving
if (status == mapstate.idle) 
|| (status == mapstate.wait) 
|| (status == mapstate.preidle) {

    //Check for a panel
    panel = collision_point(x+xorig, y+yorig, obj_levelpanel, 0, 0);
    
    //If the map HUD exists
    if (instance_exists(obj_hud_map)) {
    
        //If there's a panel, print the name on the HUD
        if (panel)
            obj_hud_map.levelname = string(panel.levelname);
        else
            obj_hud_map.levelname = "";   
                     
    }
    
    if (status != mapstate.wait) {
    
        //Do not allow movement if there's paths opening
        if (is_ready == 0)
        &amp;&amp; (obj_controller.fade == 1)
        &amp;&amp; (instance_number(obj_mapopener) == 0) {
    
            //Moving upwards
            if (input_check(input.up)) {
            
                //Check for a path above
                var pathU = collision_point(x+xorig, y+yorig-8, obj_pathparent, 0, 0);
            
                //If there's a path above and it is visible
                if (pathU) 
                &amp;&amp; (pathU.image_alpha == 1) {
                
                    direct = 90;
                    status = mapstate.prep;
                }
            }
            
            //Moving downwards
            else if (input_check(input.down)) {
            
                //Check for a path above
                var pathD = collision_point(x+xorig, y+yorig+9, obj_pathparent, 0, 0);
            
                //If there's a path above and it is visible
                if (pathD) 
                &amp;&amp; (pathD.image_alpha == 1) {
                
                    direct = 270;
                    status = mapstate.prep;
                }
            }
            
            //Moving to the left
            else if (input_check(input.left)) {
            
                //Check for a path above
                var pathL = collision_point(x+xorig-8, y+yorig, obj_pathparent, 0, 0);
            
                //If there's a path above and it is visible
                if (pathL) 
                &amp;&amp; (pathL.image_alpha == 1) {
                
                    direct = 180;
                    status = mapstate.prep;
                }
            }
            
            //Moving to the right
            else if (input_check(input.right)) {
            
                //Check for a path above
                var pathR = collision_point(x+xorig+9, y+yorig, obj_pathparent, 0, 0);
            
                //If there's a path above and it is visible
                if (pathR) 
                &amp;&amp; (pathR.image_alpha == 1) {
                
                    direct = 0;
                    status = mapstate.prep;
                }
            }
                
            //Change player
            if (input_check_pressed(input.select) &amp;&amp; instance_exists(obj_mapplayer_switcher)) {
            
                last_player = global.player;
            
                global.player ++;
                if (global.player &gt; 3)
                    global.player = 0;
                    
                status = mapstate.switching;
                    
            }
            
            //If there's a panel and this panel is available        
            if (panel)
            &amp;&amp; (panel.beaten &lt; 2)
            &amp;&amp; ((status == mapstate.idle)
            || (status == mapstate.preidle))
            &amp;&amp; ((input_check_pressed(input.action0))
            || (input_check_pressed(input.action2))) {
            
                //Play 'Enter Stage' sound
                audio_stop_play_sound(snd_enterstage, 0, false);
            
                //The player is ready
                is_ready = 1;
                
                //Stop music
                obj_mapmanager.alarm[1] = 1;
                
                //Go to the stage
                panel.alarm[1] = 60;
            }
        
        }
    }
    
}

//Otherwise, if the player is moving
else if (status == mapstate.walk) {

    //Update steps
    step += spd;
    while (step &gt;= 1) {
    
        //Travel through paths
        if (collision_point(x+xorig+cos(degtorad(direct)), y+yorig-sin(degtorad(direct)), obj_pathparent, 1, 0)) {
        
            x += cos(degtorad(direct));
            y += -sin(degtorad(direct));
        }
        else if (collision_point(x+xorig+cos(degtorad(direct))-sin(degtorad(direct)), y+yorig-sin(degtorad(direct))-cos(degtorad(direct)), obj_pathparent, 1, 0)) {
        
            x += cos(degtorad(direct))-sin(degtorad(direct));
            y += -sin(degtorad(direct))-cos(degtorad(direct));
        }
        else if (collision_point(x+xorig+cos(degtorad(direct))+sin(degtorad(direct)), y+yorig-sin(degtorad(direct))+cos(degtorad(direct)), obj_pathparent, 1, 0)) {
        
            x += cos(degtorad(direct))+sin(degtorad(direct));
            y += -sin(degtorad(direct))+cos(degtorad(direct));
        }
        else if (collision_point(x+xorig-sin(degtorad(direct)), y+yorig-cos(degtorad(direct)), obj_pathparent, 1, 0)) {
        
            x += -sin(degtorad(direct));
            y += -cos(degtorad(direct));
            direct += 90;
        }
        else if (collision_point(x+xorig+sin(degtorad(direct)), y+yorig+cos(degtorad(direct)), obj_pathparent, 1, 0)) {
        
            x += sin(degtorad(direct));
            y += cos(degtorad(direct));
            direct -= 90;
        }
        else 
            direct += 180;
        
        //Reset angles
        if (direct &lt; 0) then direct += 360;
        if (direct &gt;= 360) then direct -= 360;
        
        //Stop when inside a node
        node = collision_point(x+xorig, y+yorig, obj_node, 0, 0);
        
        //If there's a node
        if (node) {
        
            //If the player is at the center of the node
            if (x+xorig == node.x+7)
            &amp;&amp; (y+yorig == node.y+7) {
            
                //Play 'Move' sound
                audio_stop_play_sound(snd_move, 0, false);
            
                //Set stop state
                status = mapstate.preidle;
                
                //Wait to be able to walk again
                alarm[2] = 20;
                
                //Reset steps
                step = 0;
                
                //Exit
                exit;
            }
        }
        
        //Update step
        step--;
    }
            
    //Update spd
    if (is_climbing == false)
        spd = 1;
    else
        spd = 0.5;
}

//Check for a climbing object
if (collision_point(x+xorig, y+yorig, obj_climb, 0, 0))
    is_climbing = true;
else
    is_climbing = false;
    
//Check for a swimming object
if (collision_point(x+xorig, y+yorig, obj_swim, 0, 0))
    is_swimming = true;
else
    is_swimming = false;
    
//If the player is standing still...
if (status == mapstate.idle) {

    //If a level isn't about to start and there is no map switcher already...
    if (!is_ready &amp;&amp; !instance_exists(obj_mapplayer_switcher)) {
    
        //If wait time isn't over
        if (player_wait &lt; wait_time) {
    
            //Add to wait time
            player_wait ++;
            
            //If wait time has been reached...
            if (player_wait == wait_time) {
            
                //Create the switcher, and...
                with (instance_create(x,y,obj_mapplayer_switcher)) {
                
                    //Set their destination position
                    dest_x = other.x + 16;
                
                }
                
                //Rest the player wait timer
                player_wait = 0;
            
            }
            
        }
        
    }

} else {

    //If the player is getting ready to move...
    if (status == mapstate.prep) {

        //And there's no map buddy...
        if (!instance_exists(obj_mapplayer_switcher)) {
    
            //Start walking.
            status = mapstate.walk;
        
        //Otherwise...
        } else {
        
            //If the map buddy has finished their initial movement...
            if (obj_mapplayer_switcher.state == 2) {
            
                //Start bringing them back to the player.
                obj_mapplayer_switcher.state = 3;
            
            }
            
        }
        
    } else if (status == mapstate.switching) {
    
        //Face forward
        direct = 270;
    
        //If the map buddy has finished their initial movement...
        if (obj_mapplayer_switcher.state == 2) {
        
            //Start bringing them back to the player.
            obj_mapplayer_switcher.state = 3;
            obj_mapplayer_switcher.switching = true;
            obj_mapplayer_switcher.depth = depth-1;
        
        }
    
    }
    
    //Reset wait time
    player_wait = 0;

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Open adyacent paths

//Check for a path above and open it if it is not visible
var pathU = collision_point(x+xorig, y+yorig-8, obj_pathparent, 0, 0);
if (pathU) 
&amp;&amp; (pathU.image_alpha == 0)
    with (instance_create(x, y, obj_mapopener)) direct = 90;

//Check for a path below and open it if it is not visible
var pathD = collision_point(x+xorig, y+yorig+9, obj_pathparent, 0, 0);
if (pathD) 
&amp;&amp; (pathD.image_alpha == 0) 
    with (instance_create(x, y, obj_mapopener)) direct = 270;

//Check for a path at the left and open it if it is not visible
var pathL = collision_point(x+xorig-8, y+yorig, obj_pathparent, 0, 0);
if (pathL) 
&amp;&amp; (pathL.image_alpha == 0)
    with (instance_create(x, y, obj_mapopener)) direct = 180;

//Check for a path at the right and open it if it is not visible
var pathR = collision_point(x+xorig+9, y+yorig, obj_pathparent, 0, 0);
if (pathR) 
&amp;&amp; (pathR.image_alpha == 0)
    with (instance_create(x, y, obj_mapopener)) direct = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Replace last map position

ds_map_replace(global.worldmap, "playerx", x);
ds_map_replace(global.worldmap, "playery", y);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw the player

//If the player is riding a yoshi
if (global.mount != 0) {

    pal_swap_set(spr_palette_yoshi, global.mountcolour);
}

//Draw normally
if (xscale == 1)
    draw_sprite(sprite_index, image_index, round(x), round(y)-4+(4*is_swimming));
else
    draw_sprite_ext(sprite_index, image_index, round(x)+16, round(y)-4+(4*is_swimming), -1, 1, 0, c_white, 1);
    
//Reset the shader
pal_swap_reset();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
