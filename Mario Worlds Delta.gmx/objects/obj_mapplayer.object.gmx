<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_mapmario</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>spr_square</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///It's the player... on the map!

//Animate the object
image_speed = 0.15;

//Whether the object is moving
status = 'IDLE';

//Speed
spd = 1;

//Origin
xorig = 7;
yorig = 7;

//Steps to take per steps
step = 0;

//Direction
direct = 270;

//Whether the player is climbing
is_climbing = 0;

//Whether the player is swimming
is_swimming = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Animate the object

//If climbing
if (is_climbing) {

    sprite_index = spr_mapmario_climb;
    xscale = 1;
}

//Otherwise, if not climbing
else {

    //If moving down or stopped
    if (direct == 270)
    || (status == 'IDLE') {
    
        //Reset scale
        xscale = 1;
        
        //If not swimming
        if (!is_swimming)
            sprite_index = spr_mapmario;
        else
            sprite_index = spr_mapmario_water;
    }
    
    //Otherwise, if moving up
    else if (direct == 90) {
    
        //Reset scale
        xscale = 1;
        
        //If not swimming
        if (!is_swimming)
            sprite_index = spr_mapmario_up;
        else
            sprite_index = spr_mapmario_water_up;
    }
        
    //Otherwise, if moving to the side
    else {
        
        //Set the scale
        if (direct == 0)
            xscale = 1;
        else
            xscale = -1;
        
        //If not swimming
        if (!is_swimming)
            sprite_index = spr_mapmario_side;
        else
            sprite_index = spr_mapmario_water_side;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Engine logic

//Update animation speed
image_speed = 0.15;

//If the player is not moving
if (status == 'IDLE') {

    //Moving upwards
    if (keyboard_check(global.key_u)) {
    
        //Check for a path above
        var pathU = collision_point(x+xorig, y+yorig-16, obj_pathparent, 0, 0);
    
        //If there's a path above and it is visible
        if (pathU) 
        &amp;&amp; (pathU.image_alpha == 1) {
        
            direct = 90;
            status = 'WALK';
        }
    }
    
    //Moving downwards
    else if (keyboard_check(global.key_d)) {
    
        //Check for a path above
        var pathD = collision_point(x+xorig, y+yorig+16, obj_pathparent, 0, 0);
    
        //If there's a path above and it is visible
        if (pathD) 
        &amp;&amp; (pathD.image_alpha == 1) {
        
            direct = 270;
            status = 'WALK';
        }
    }
    
    //Moving to the left
    else if (keyboard_check(global.key_l)) {
    
        //Check for a path above
        var pathL = collision_point(x+xorig-16, y+yorig, obj_pathparent, 0, 0);
    
        //If there's a path above and it is visible
        if (pathL) 
        &amp;&amp; (pathL.image_alpha == 1) {
        
            direct = 180;
            status = 'WALK';
        }
    }
    
    //Moving to the right
    else if (keyboard_check(global.key_r)) {
    
        //Check for a path above
        var pathR = collision_point(x+xorig+16, y+yorig, obj_pathparent, 0, 0);
    
        //If there's a path above and it is visible
        if (pathR) 
        &amp;&amp; (pathR.image_alpha == 1) {
        
            direct = 0;
            status = 'WALK';
        }
    }
    
    //Allow unlock of adyacent paths if playing in debug mode
    if (keyboard_check_pressed(ord('O')))
        event_user(15);
}

//Otherwise, if the player is moving
else if (status == 'WALK') {

    //Update steps
    step += spd;
    while (step &gt;= 1) {
    
        //Travel through paths
        if (collision_point(x+xorig+cos(degtorad(direct)), y+yorig-sin(degtorad(direct)), obj_pathparent, 1, 0)) {
        
            x += cos(degtorad(direct));
            y += -sin(degtorad(direct));
        }
        else if (collision_point(x+xorig+cos(degtorad(direct))-sin(degtorad(direct)), y+yorig-sin(degtorad(direct))-cos(degtorad(direct)), obj_pathparent, 1, 0)) {
        
            x += cos(degtorad(direct))-sin(degtorad(direct));
            y += -sin(degtorad(direct))-cos(degtorad(direct));
        }
        else if (collision_point(x+xorig+cos(degtorad(direct))+sin(degtorad(direct)), y+yorig-sin(degtorad(direct))+cos(degtorad(direct)), obj_pathparent, 1, 0)) {
        
            x += cos(degtorad(direct))+sin(degtorad(direct));
            y += -sin(degtorad(direct))+cos(degtorad(direct));
        }
        else if (collision_point(x+xorig-sin(degtorad(direct)), y+yorig-cos(degtorad(direct)), obj_pathparent, 1, 0)) {
        
            x += -sin(degtorad(direct));
            y += -cos(degtorad(direct));
            direct += 90;
        }
        else if (collision_point(x+xorig+sin(degtorad(direct)), y+yorig+cos(degtorad(direct)), obj_pathparent, 1, 0)) {
        
            x += sin(degtorad(direct));
            y += cos(degtorad(direct));
            direct -= 90;
        }
        else 
            direct += 180;
        
        //Reset angles
        if (direct &lt; 0) then direct += 360;
        if (direct &gt;= 360) then direct -= 360;
        
        //Stop when inside a node
        node = collision_point(x+xorig, y+yorig, obj_node, 0, 0);
        
        //If there's a node
        if (node) {
        
            //If the player is at the center of the node
            if (x+xorig == node.x+7)
            &amp;&amp; (y+yorig == node.y+7) {
            
                //Play 'Move' sound
                audio_play_sound(snd_move, 0, false);
            
                //Set stop state
                status = 'IDLE';
                
                //Reset steps
                step = 0;
                
                //Exit
                exit;
            }
        }
        
        //Update step
        step--;
    }
            
    //Update spd
    if (is_climbing == false)
        spd = 1;
    else
        spd = 0.5;
}

//Check for a climbing object
if (collision_point(x+xorig, y+yorig, obj_climb, 0, 0))
    is_climbing = true;
else
    is_climbing = false;
    
//Check for a swimming object
if (collision_point(x+xorig, y+yorig, obj_swim, 0, 0))
    is_swimming = true;
else
    is_swimming = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///DEBUG FUNCTION: Open adyacent paths

//Check for a path above and open it if it is not visible
var pathU = collision_point(x+xorig, y+yorig-16, obj_pathparent, 0, 0);
if (pathU) 
&amp;&amp; (pathU.image_alpha == 0)
    with (instance_create(x, y, obj_mapopener)) direct = 90;

//Check for a path below and open it if it is not visible
var pathD = collision_point(x+xorig, y+yorig+16, obj_pathparent, 0, 0);
if (pathD) 
&amp;&amp; (pathD.image_alpha == 0) 
    with (instance_create(x, y, obj_mapopener)) direct = 270;

//Check for a path at the left and open it if it is not visible
var pathL = collision_point(x+xorig-16, y+yorig, obj_pathparent, 0, 0);
if (pathL) 
&amp;&amp; (pathL.image_alpha == 0)
    with (instance_create(x, y, obj_mapopener)) direct = 180;

//Check for a path at the right and open it if it is not visible
var pathR = collision_point(x+xorig+16, y+yorig, obj_pathparent, 0, 0);
if (pathR) 
&amp;&amp; (pathR.image_alpha == 0)
    with (instance_create(x, y, obj_mapopener)) direct = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw the player

if (xscale == 1)
    draw_sprite(sprite_index, -1, round(x), round(y)-4);
else
    draw_sprite_ext(sprite_index, -1, round(x)+16, round(y)-4, -1, 1, 0, c_white, 1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
